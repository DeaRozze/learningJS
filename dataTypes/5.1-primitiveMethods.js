МЕТОДЫ ПРИМИТИВОВ

JS позволяет нам работать с примитивными типами данных, как будто они объекты. 
У них есть методы.

  ПРИМИТИВ

  - Это - значение "примитивного" типа.
- есть 7 примитивных типов

ОБЪЕКТ

  - Может хранить множество значений как св - ва.
- Объявляется при  помощи фигурных скобок { }

ОДНА из лучших особенностей объектов - это то, что мы можем хранить функци.как одно из св - в объекта.

  Объекты «тяжелее» примитивов.Они нуждаются в дополнительных ресурсах для поддержания внутренней структуры.

ПРИМИТИВ КАК ОБЪЕКТ

Вот парадокс, с которым столкнулся создатель JavaScript:

-Есть много всего, что хотелось бы сделать с примитивами, такими как строка или число. 
 Было бы замечательно, если бы мы могли обращаться к ним при помощи методов.

- Примитивы должны быть лёгкими и быстрыми насколько это возможно.

Выбранное решение, хотя выглядит оно немного неуклюже:

- Примитивы остаются примитивами.Одно значение, как и хотелось.
- Язык позволяет осуществлять доступ к методам и свойствам строк, чисел, булевых значений и символов.
- Чтобы это работало, при таком доступе создаётся специальный «объект - обёртка», который предоставляет нужную функциональность, а после удаляется.

Каждый примитив имеет свой собственный «объект - обёртку», которые называются: String, Number, Boolean, Symbol и BigInt. 
Таким образом, они имеют разный набор методов.

К примеру, существует метод str.toUpperCase(), который возвращает строку в верхнем регистре.

  Вот, как он работает:

let str = "Привет";

alert(str.toUpperCase()); // ПРИВЕТ

Очень просто, не правда ли ? Вот, что на самом деле происходит в str.toUpperCase():

- Строка str – примитив.В момент обращения к его свойству, создаётся специальный объект,
  который знает значение строки и имеет такие полезные методы, как toUpperCase().
- Этот метод запускается и возвращает новую строку(показывается в alert).
- Специальный объект удаляется, оставляя только примитив str.

Число имеет собственный набор методов.Например, toFixed(n) округляет число до n знаков после запятой.

let num = 1.23456;

alert(num.toFixed(2)); // 1.23

КОНСТРУКТОРЫ String / Number / Boolean ПРЕДНАЗНАЧЕНЫ ТОЛЬКО ДЛЯ ВНУТРЕННЕГО ПОЛЬЗОВАНИЯ

Некоторые языки, такие как Java, позволяют явное создание «объектов - обёрток» для примитивов при помощи такого синтаксиса как new Number(1) или new Boolean(false).

В JavaScript, это тоже возможно по историческим причинам, но очень не рекомендуется.В некоторых местах последствия могут быть катастрофическими.

  Например:

alert(typeof 0); // "число"

alert(typeof new Number(0)); // "object"!

Объекты в if всегда дают true, так что в нижеприведённом примере будет показан alert:

let zero = new Number(0);

if (zero) {
  // zero возвращает "true", так как является объектом
  alert("zero имеет «истинное» значение?!?");
}

С другой стороны, использование функций String / Number / Boolean без оператора new – вполне разумно и полезно.Они превращают значение в соответствующий примитивный тип: в строку, в число, в булевый тип.

К примеру, следующее вполне допустимо:

let num = Number("123"); // превращает строку в число

null / undefined НЕ ИМЕЮТ МЕТОДОВ

Особенные примитивы null и undefined являются исключениями.У них нет соответствующих «объектов - обёрток», и они не имеют никаких методов.В некотором смысле, они «самые примитивные».

Попытка доступа к свойствам такого значения возвратит ошибку:

alert(null.test); // ошибка

Итого
Все примитивы, кроме null и undefined, предоставляют множество полезных методов.Мы познакомимся с ними поближе в следующих главах.
Формально эти методы работают с помощью временных объектов, но движки JavaScript внутренне очень хорошо оптимизируют этот процесс, так что их вызов не требует много ресурсов.


Попробуйте запустить код:

let str = "Привет";

str.test = 5; // (*)

alert(str.test);
В зависимости от того, используете ли вы строгий режим (use strict) или нет, результат может быть:

undefined (без strict)
Ошибка (strict mode)
Почему? Давайте посмотрим что происходит в строке кода, отмеченной (*):

В момент обращения к свойству str создаётся «объект-обёртка».
В строгом режиме, попытка изменения этого объекта выдаёт ошибку.
Без строгого режима, операция продолжается, объект получает свойство test, но после этого он удаляется, так что на последней линии str больше не имеет свойства test.
Данный пример наглядно показывает, что примитивы не являются объектами.

Они не могут хранить дополнительные данные.