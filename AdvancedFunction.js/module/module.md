# Модули, введение

Модуль – это просто файл. Один скрипт – это один модуль.

Модули могут загружать друг друга и использовать директивы `export` и `import`, чтобы обмениваться функциональностью, вызывать функции одного модуля из другого:

- `export` отмечает переменные и функции, которые должны быть доступны вне текущего модуля.

- `import` позволяет импортировать функциональность из других модулей.

### Всегда «use strict»

В модулях всегда используется режим `use strict`. Например, присваивание к необъявленной переменной вызовет ошибку.

### Своя область видимости переменных

Каждый модуль имеет свою собственную область видимости. Другими словами, переменные и функции, объявленные в модуле, не видны в других скриптах.

В браузере также существует независимая область видимости для каждого скрипта `<script type="module">`:

Если нам нужно сделать глобальную переменную уровня всей страницы, можно явно присвоить её объекту window, тогда получить значение переменной можно обратившись к `window.user`. Но это должно быть исключением, требующим веской причины.

### Код в модуле выполняется только один раз при импорте

Если один и тот же модуль используется в нескольких местах, то его код выполнится только один раз, после чего экспортируемая функциональность передаётся всем импортёрам.

Ещё раз заметим – модуль выполняется только один раз. Генерируется экспорт и после передаётся всем импортёрам, поэтому, если что-то изменится в объекте `admin`, то другие модули тоже увидят эти изменения.

Такое поведение позволяет `конфигурировать` модули при первом импорте. Мы можем установить его свойства один раз, и в дальнейших импортах он будет уже настроенным.

### В модуле «this» не определён

Это незначительная особенность, но для полноты картины нам нужно упомянуть об этом.

В модуле на верхнем уровне `this` не определён `(undefined)`.

```javascript
<script>
  alert(this); // window
</script>

<script type="module">
  alert(this); // undefined
</script>
```

## Особенности в браузерах

### Модули являются отложенными (deferred)

Модули всегда выполняются в отложенном `(deferred)` режиме, точно так же, как скрипты с атрибутом `defer` (описан в главе Скрипты: `async, defer`). Это верно и для внешних и встроенных скриптов-модулей.

Другими словами:

- загрузка внешних модулей, таких как `<script type="module" src="...">`, не блокирует обработку `HTML`.

- модули, даже если загрузились быстро, ожидают полной загрузки `HTML` документа, и только затем выполняются.

- сохраняется относительный порядок скриптов: скрипты, которые идут раньше в документе, выполняются раньше.

При использовании модулей нам стоит иметь в виду, что `HTML`-страница будет показана браузером до того, как выполнятся модули и `JavaScript`-приложение будет готово к работе. Некоторые функции могут ещё не работать. Нам следует разместить «индикатор загрузки» или что-то ещё, чтобы не смутить этим посетителя.

### Атрибут async работает во встроенных скриптах

Для не-модульных скриптов атрибут `async` работает только на внешних скриптах. Скрипты с ним запускаются сразу по готовности, они не ждут другие скрипты или `HTML`-документ.

Для модулей атрибут `async`работает на любых скриптах.

Скрипт выполнит импорт (загрузит `./analytics.js`) и сразу запустится, когда будет готов, даже если `HTML` документ ещё не будет загружен, или если другие скрипты ещё загружаются.

Это очень полезно, когда модуль ни с чем не связан, например для счётчиков, рекламы, обработчиков событий.

```javascript
<!-- загружаются зависимости (analytics.js) и скрипт запускается -->
<!-- модуль не ожидает загрузки документа или других тэгов <script> -->
<script async type="module">
  import {counter} from './analytics.js';

  counter.count();
</script>
```

### Внешние скрипты

Внешние скрипты с атрибутом `type="module"` имеют два отличия:

1. Внешние скрипты с одинаковым атрибутом `src` запускаются только один раз:

```javascript
<!-- скрипт my.js загрузится и будет выполнен только один раз -->
<script type="module" src="my.js"></script>
<script type="module" src="my.js"></script>
```

2. Внешний скрипт, который загружается с другого домена, требует указания заголовков `CORS`. Другими словами, если модульный скрипт загружается с другого домена, то удалённый сервер должен установить заголовок `Access-Control-Allow-Origin` означающий, что загрузка скрипта разрешена.

```javascript
<!-- another-site.com должен указать заголовок Access-Control-Allow-Origin -->
<!-- иначе, скрипт не выполнится -->
<script type="module" src="http://another-site.com/their.js"></script>
```

Это обеспечивает лучшую безопасность по умолчанию.

### Не допускаются «голые» модули

В браузере `import` должен содержать относительный или абсолютный путь к модулю. Модули без пути называются «голыми» `(bare)`. Они не разрешены в `import`.

Другие окружения, например `Node.js`, допускают использование «голых» модулей, без путей, так как в них есть свои правила, как работать с такими модулями и где их искать. Но браузеры пока не поддерживают «голые» модули.

### Совместимость, «nomodule»

Старые браузеры не понимают атрибут `type="module"`. Скрипты с неизвестным атрибутом `type` просто игнорируются. Мы можем сделать для них «`резервный»` скрипт при помощи атрибута `nomodule`:

```javascript
<script type="module">
  alert("Работает в современных браузерах");
</script>

<script nomodule>
  alert("Современные браузеры понимают оба атрибута - и type=module, и nomodule, поэтому пропускают этот тег script")
  alert("Старые браузеры игнорируют скрипты с неизвестным атрибутом type=module, но выполняют этот.");
</script>
```

### Инструменты сборки

В реальной жизни модули в браузерах редко используются в `«сыром»` виде. Обычно, мы объединяем модули вместе, используя специальный инструмент, например `Webpack` и после выкладываем код на рабочий сервер.

Одно из преимуществ использования сборщика – он предоставляет больший контроль над тем, как модули ищутся, позволяет использовать «голые» модули и многое другое «своё», например `CSS/HTML-модули`.

Сборщик делает следующее:

1. Берёт `«основной»` модуль, который мы собираемся поместить в `<script type="module">` `в HTML`.

2. Анализирует зависимости (импорты, импорты импортов и так далее)

3. Собирает один файл со всеми модулями (или несколько файлов, это можно настроить), перезаписывает встроенный `import` функцией импорта от сборщика, чтобы всё работало. `«Специальные»` типы модулей, такие как `HTML/CSS` тоже поддерживаются.

4. В процессе могут происходить и другие трансформации и оптимизации кода

- Недостижимый код удаляется.

- Неиспользуемые экспорты удаляются («tree-shaking»).

- Специфические операторы для разработки, такие как `console` и `debugger`, удаляются.

- Современный синтаксис `JavaScript` также может быть трансформирован в предыдущий стандарт, с похожей функциональностью, например, с помощью `Babel`.

- Полученный файл можно минимизировать (удалить пробелы, заменить названия переменных на более короткие и т.д.).

# Итого

1. Модуль – это файл. Чтобы работал `import/export`, нужно для браузеров указывать атрибут `<script type="module">`. У модулей есть ряд особенностей:
- Отложенное `(deferred)` выполнение по умолчанию.
- Атрибут `async` работает во встроенных скриптах.
- Для загрузки внешних модулей с другого источника, он должен ставить заголовки `CORS`.
- Дублирующиеся внешние скрипты игнорируются.

2. У модулей есть своя область видимости, обмениваться функциональностью можно через `import/export`.

3. В модулях всегда включена директива `use strict`.

4. Код в модулях выполняется только один раз. Экспортируемая функциональность создаётся один раз и передаётся всем импортёрам.

Когда мы используем модули, каждый модуль реализует свою функциональность и экспортирует её. Затем мы используем `import`, чтобы напрямую импортировать её туда, куда необходимо. Браузер загружает и анализирует скрипты автоматически.

В реальной жизни часто используется сборщик `Webpack`, чтобы объединить модули: для производительности и других «плюшек».

В следующей главе мы увидим больше примеров и вариантов импорта/экспорта.