КОНСТРУКТО, ОПЕРАТОР new

  ДЛЯ СОЗДАНИЙ МНОЖЕСТВА ПОХОЖИХ, ОБНОТИПНЫХ ОБЪЕКТОВ, ТАКИХ КАК ПОЛЬЗОВАТЕЛИ, ЭЛЕМЕНТ ЫМЕНЮ И ТАК ДАЛЕЕ МОЖНО ИСПОЛЬЗОВАТЬ ФУНКЦИИ_ КОСТРУКТОРЫ И ОПЕРАТОР new

    ФУНКЦИЯ_КОНСТРУКТОР

технически обычные функции, но есть два соглашения:

-ИМЯ ФУНКЦИИ - КОНСТРУКТОРА ДОЛЖНО НАЧИНАТЬСЯ С БОЛЬШОЙ БУКВЫ.
- ФУНКЦИЯ - КОНСТРУКТОР ДОЛЖНА ВЫПОЛНЯТЬСЯ ТОЛЬКО С ПОМОЩЬЮ ОПЕРАТОРА "new"

например:

function User(name) {
  this.name = name
  this.isAdmin = false
}

let user = new User("Jack")

alert(user.name) //Jack
alert(user.isAdmin) //false


Когда функция вызывается как new User(...), происходит следующее:

1. создается новый пустой объект, и он присваивается this.
2. выполняется тело функции.Обычно оно модифицирует this, добавляя туда новые св - ва.
3.Возвращается значение this.

другими словами, new User() делает что - то вроде:

function User(name) {
  // this = {};  (неявно)

  // добавляет свойства к this
  this.name = name;
  this.isAdmin = false;

  // return this;  (неявно)
}

Таким образом, let user = new User("Jack") возвращает тот же результат, что и:

let user = {
  name: "Jack",
  isAdmin: false
};

Теперь, если нам будет необходимо создать других пользователей, мы можем просто вызвать new User("Ann"), new User("Alice") и так далее.Данная конструкция гораздо удобнее и читабельнее, чем многократное создание литерала объекта.

Это и является основной целью конструкторов – реализовать код для многократного создания однотипных объектов.

Давайте ещё раз отметим – технически любая функция(кроме стрелочных функций, поскольку у них нет this) может использоваться в качестве конструктора.Его можно запустить с помощью new, и он выполнит выше указанный алгоритм.Подобные функции должны начинаться с заглавной буквы – это общепринятое соглашение, чтобы было ясно, что функция должна вызываться с помощью «new».


new function () { … }
Если в нашем коде присутствует большое количество строк, создающих один сложный объект, то мы можем обернуть их в функцию - конструктор, которая будет немедленно вызвана, вот так:

// создаём функцию и сразу же вызываем её с помощью new
let user = new function () {
  this.name = "John";
  this.isAdmin = false;

  // ...другой код для создания пользователя
  // возможна любая сложная логика и инструкции
  // локальные переменные и так далее
};
Такой конструктор не может быть вызван снова, так как он нигде не сохраняется, просто создаётся и тут же вызывается.Таким образом, этот трюк направлен на инкапсуляцию кода, который создаёт отдельный объект, без возможности повторного использования в будущем.

ПРОВЕРКА НА ВЫЗОВ В РЕЖИМЕ КОСТРУКТОРА: new.target

Продвинутая возможность
Синтаксис из этого раздела используется крайне редко.Вы можете пропустить его, если не хотите углубляться в детали языка.

Используя специальное свойство new.target внутри функции, мы можем проверить, вызвана ли функция при помощи оператора new или без него.

В случае обычного вызова функции new.target будет undefined.Если же она была вызвана при помощи new, new.target будет равен самой функции.

function User() {
  alert(new.target);
}

// без "new":
User(); // undefined

// с "new":
new User(); // function User { ... }

Такой подход иногда используется в библиотеках, чтобы сделать синтаксис более гибким.Чтобы люди могли вызывать функцию с new и без него, и она все ещё могла работать.

  Впрочем, вероятно, это не очень хорошая практика использовать этот трюк везде, так как отсутствие new может ввести разработчика в заблуждение.С new мы точно знаем, что создаётся новый объект.

ВОЗВРАТ ЗНАЧЕНИЯ ИЗ КОНСТРУКТОРА, return

Обычно конструкторы не имеют оператора return.Их задача – записать все необходимое в this, и это автоматически становится результатом.

Но если return всё же есть, то применяется простое правило:

При вызове return с объектом, вместо this вернётся объект.
При вызове return с примитивным значением, оно проигнорируется.
Другими словами, return с объектом возвращает этот объект, во всех остальных случаях возвращается this.

К примеру, здесь return замещает this, возвращая объект:

function BigUser() {

  this.name = "John";

  return { name: "Godzilla" };  // <-- возвращает этот объект
}

alert(new BigUser().name);  // Godzilla, получили этот объект
А вот пример с пустым return (или мы могли бы поставить примитив после return, неважно):

function SmallUser() {

  this.name = "John";

  return; // <-- возвращает this
}

alert(new SmallUser().name);  // John
Обычно у конструкторов отсутствует return.Здесь мы упомянули особое поведение с возвращаемыми объектами в основном для полноты картины.

Пропуск скобок
Кстати, мы можем не ставить круглые скобки после new:

let user = new User; // <-- без скобок
// то же, что и
let user = new User();
Пропуск скобок считается плохой практикой, но просто чтобы вы знали, такой синтаксис разрешён спецификацией.

СОЗДАНИЕ МЕТОДОВ В КОНСТРУКТОРЕ

Использование конструкторов для создания объектов даёт большую гибкость.Функции - конструкторы могут иметь параметры, определяющие, как создавать объект и что в него записывать.

  Конечно, мы можем добавить к this не только свойства, но и методы.

    Например, new User(name) ниже создаёт объект с заданным name и методом sayHi:

function User(name) {
  this.name = name;

  this.sayHi = function () {
    alert("Меня зовут: " + this.name);
  };
}

let john = new User("John");

john.sayHi(); // Меня зовут: John

/*
john = {
   name: "John",
   sayHi: function() { ... }
}
*/
Для создания сложных объектов есть и более продвинутый синтаксис – классы, который мы рассмотрим позже.

  ИТОГО

Функции - конструкторы или просто конструкторы, являются обычными функциями, но существует общепринятое соглашение именовать их с заглавной буквы.
  Функции - конструкторы следует вызывать только с помощью new.Такой вызов подразумевает создание пустого this в начале и возврат заполненного в конце.
Мы можем использовать конструкторы для создания множества похожих объектов.

JavaScript предоставляет функции - конструкторы для множества встроенных объектов языка: таких как Date, Set, и других, которые нам ещё предстоит изучить.


function Calculator() {
  this.read = function () {
    this.a = +prompt('a?', 0)
    this.b = +prompt('b?', 0)
  }

  this.sum = function () {
    return this.a + this.b
  }

  this.mul = function () {
    return this.a * this.b
  }
}

let calculator = new Calculator()
calculator.read()

alert("Sum=" + calculator.sum());
alert("Mul=" + calculator.mul());



function Accumulator(startingValue) {
  this.value = startingValue;

  this.read = function() {
    this.value += +prompt('Сколько нужно добавить?', 0);
  };

}

let accumulator = new Accumulator(1);
accumulator.read();
accumulator.read();
alert(accumulator.value)