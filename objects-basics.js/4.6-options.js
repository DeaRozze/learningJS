ОПЦИОНАЛЬНАЯ ЦЕПОЧКА '?.'

Это безопасный способ доступа к св - вам вложенных объектов, даже если какое - либо из промежуточных св - в не существует.

ПРОБЛЕМА НЕСУЩЕСТВУЮЩЕГО СВ - ВА

let user = {}; // пользователь без свойства "address"

alert(user.address.street); // Ошибка!

Поскольку user.address имеет значение undefined, попытка получить user.address.street завершается ошибкой.

Очевидным решением было бы проверить значение с помощью if или условного оператора ?, прежде чем обращаться к его свойству, вот так:

let user = {};

alert(user.address ? user.address.street : undefined);

Для более глубоко вложенных свойств это ещё менее красиво, поскольку потребуется больше повторений.

К примеру, давайте аналогично вычислим user.address.street.name.


ОПЦИОНАЛЬНАЯ ЦЕПОЧКА

Опциональная цепочка?.останавливает вычисление и возвращает undefined, если значение перед?.равно undefined или null.

Другими словами, value?.prop:

работает как value.prop, если значение value существует,
  в противном случае(когда value равно undefined / null) он возвращает undefined.
Вот безопасный способ получить доступ к user.address.street, используя?.:

let user = {}; // пользователь без адреса

alert(user?.address?.street); // undefined (без ошибки)

Код лаконичный и понятный, в нем вообще нет дублирования.

А вот пример с document.querySelector:

let html = document.querySelector('.elem')?.innerHTML; // будет undefined, если элемента нет

Считывание адреса с помощью user?.address работает, даже если объект user не существует:

let user = null;

alert(user?.address); // undefined
alert(user?.address.street); // undefined
Обратите внимание: синтаксис?.делает необязательным значение перед ним, но не какое - либо последующее.

НЕ ЗЛОУПОТРЕБЛЯЕЙТЕ ОПЦИОНАЛЬНОЙ ЦЕПОЧКОЙ
Нам следует использовать?.только там, где нормально, что чего - то не существует.

К примеру, если, в соответствии с логикой нашего кода, объект user должен существовать,
  но address является необязательным, то нам следует писать user.address?.street, но не user?.address?.street.

ПЕРЕМЕННАЯ перед?.должна быть объявлена
Если переменной user вообще нет, то user?.anything приведёт к ошибке:

// ReferenceError: user is not defined
user?.address;

СОКРАЩЕННОЕ ВЫЧИСЛЕНИЕ

Как было сказано ранее, ?.немедленно останавливает вычисление, если левая часть не существует.
Так что если после?.есть какие - то вызовы функций или операции, то они не произойдут.

let user = null;
let x = 0;

user?.sayHi(x++); // нет "user", поэтому выполнение не достигает вызова sayHi и x++

alert(x); // 0, значение не увеличилось

ДРУГИЕ ВАРИАНТЫ ПРИМЕНЕНИЯ: ?.(), ?.[]

ОПЦИОНАЛЬНАЯ ЦЕПОЧКА?. - НЕ ОПЕРАТОР, а специальная синтаксическая конструкция, которая также работает с функциями и квадратными скобками.

  Например, ?.() используется для вызова функции, которая может не существовать.

    Например, ?.() используется для вызова функции, которая может не существовать.

В приведённом ниже коде у некоторых наших пользователей есть метод admin, а у некоторых его нет:

let userAdmin = {
  admin() {
    alert("Я админ");
  }
};

let userGuest = {};

userAdmin.admin?.(); // Я админ

userGuest.admin?.(); // ничего не произойдет (такого метода нет)
Здесь в обеих строках мы сначала используем точку(userAdmin.admin), чтобы получить свойство admin, потому что мы предполагаем, что объект userAdmin существует, так что читать из него безопасно.

  Затем?.() проверяет левую часть: если функция admin существует, то она запускается(это так для userAdmin).В противном случае(для userGuest) вычисление остановится без ошибок.

    Синтаксис?.[] также работает, если мы хотим использовать скобки[] для доступа к свойствам вместо точки..Как и в предыдущих случаях, он позволяет безопасно считывать свойство из объекта, который может не существовать.

let key = "firstName";

let user1 = {
  firstName: "John"
};

let user2 = null;

alert(user1?.[key]); // John
alert(user2?.[key]); // undefined
Также мы можем использовать?.с delete:

delete user?.name; // удаляет user.name если пользователь существует


ИТОГО

Синтаксис опциональной цепочки?.имеет три формы:

obj?.prop – возвращает obj.prop если obj существует, в противном случае undefined.
  obj?.[prop] – возвращает obj[prop] если obj существует, в противном случае undefined.
    obj.method?.() – вызывает obj.method(), если obj.method существует, в противном случае возвращает undefined.
?.проверяет левую часть на null / undefined и позволяет продолжить вычисление, если это не так.

  Цепочка?.позволяет безопасно получать доступ к вложенным свойствам.

Тем не менее, мы должны использовать?.осторожно, только там, где по логике кода допустимо, что левая часть не существует.
Чтобы он не скрывал от нас ошибки программирования, если они возникнут.

const auto = {
  brand: 'Tesla',
  model: ' ModelX',
  // details: {
  //   color: 'Красный',
  //   year: 2021,
  //   atStock: true,
  // },
}

const cars = [auto];

ЕСЛИ УБРАТЬ ВЛОЖЕННОСТЬ В ОБЪЕКТЕ - ТО БУДЕТ ОШИБКА
cars.forEach(car => {
  console.log(`${car.brand} ${car.detatils.year}: цвет - ${car.details.color}`)
})

ВАРИАНТ ИСПРАВЛЕНИЯ ОШИБКИ(БУДЕТ МЕНЯТЬ НА undefined), проверок может быть очень много - это загрязнение
cars.forEach(car => {
  console.log(`${car.brand} ${car.detatils && car.detatils.year}: цвет - ${car.detatils && car.details.color}`)
})


ВАРИНТА ПРАВиЛЬНЫЙ

cars.forEach(car => {
  console.log(`${car.brand} ${car.detatils?.year}: цвет - ${car.details?.color}`)
})

РАБОТАЕТ С МЕТОДАМИ

const auto = {
  brand: 'Tesla',
  model: ' ModelX',
  // drive() {
  //   console.log('rrrrrrrr');
  // }
}

auto.drive?.()

const auto = null

console.log(auto?.['brand']);
