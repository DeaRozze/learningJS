Объект - это набор св - в.Каждое св - во состоит из названия и значения. 
Название может быть строкой или символом, а зачение может быть любым.

Создаются объекты с помощью конструктора Object

const book = new Object(
  { title: 'Война и мир', author: 'Лев Толстой' }
)

и с помощью ЛИТЕРАЛЬНОЙ ЗАПИСИ.
пустой объект без св - в можно создать парой фигурных скобок

const cat = {}

когда нужно создать объект со св - вами, то их описывают внутрни фигурных скобок.
  Св - ва указываются в формате имяСвойста: значение, между св - вами ставится запятая

const book = {
  title: 'Война и мир',
  author: 'Лев Толстой',
  pages: 1274,
  isFinish: true
}

ЗНАЧЕНИЕМ МОЖЕТ БЫТЬ ДРУГОЙ ОБЪЕКТ ИЛИ МАССИВ:

const cat = {
  kittens: ['Беляш', 'Михаил', 'Чарли',],
  favouriteToy: {
    name: 'мячик',
    size: 'маленький'
  },
}

или даже функция

const cat = {
  name: 'Tom',
  meow: function () {
    console.log('мяу-мяу');
  },
}
cat.meow

СВ - ВА можно добавлять и после создания объекта:

Свойства объекта — это переменные, которые принадлежат объекту.

const cat = {}
cat.name = 'Simon'
console.log(cat); //Simon

!!Несмотря на то, что переменная cat объявлена неизменяемой, свойства хранимого объекта можно менять.
Дело в том, что объект хранится по ссылке.Изменение внутреннего состояния не изменяет ссылку.

Объявление const защищает от изменений только саму переменную user, а не ее содержимое.

  ЧТЕНИЕ СВ-В:

С ПОМОЩЬЮ ТОЧКИ

  - Значение может быть любого типа.

- Для удаления св - ва мы можем использовать оператор delete:
delete user.age;

-Имя св - ва может состоять из нескольких слов, но тогда оно должно быть заключено в кавычки


КВАДРЫТНЫХ СКОБОК

user.likes birds = true //Вызовет синтаксическую ошибку

  - Для св - в, имена которых состоят из нескольких слов, доступ к значению < через точку > не работает

    - ключ не должен иметь пробелы, не начинался с цифры и не содержал специальные символы, кроме $ и _

      - Квадратные скобки также позволяют обратитьсмя к свойству, имя которого может быть результатом выражения. 
Например имя св - ва может хранится в переменной:
let key = "likes birds"

//то же самое что и user["likes birds"] = true
user[key] = true

let user = {};
//присваиваем занчение свойству
user['likes birds'] = true;

//получение значения свойства
alert(user['likes birds']) //true

//удаление свойства
delete user['likes birds'];

ОБРАТИТЕ ВНИМАНИЕ что строка в квадратных скобках заключена в кавычки


ДОБАВЛЕНИЕ И ИЗМЕНЕНИЕ СВ - В

const book = {
  title: 'Капитанская дочка'
}

//добавляем новое св-во
book.author = 'А. С. Пушкин'

//изменяем св-во
book.title = 'Сказка о царе Салтане'
console.log(book)
// { title: 'Сказка о царе Салтане', author: 'А. С. Пушкин'}

Чаще всего свойства не удаляют, а сбрасывают значение, устанавливая undefined или подходящее по смыслу:

const book = {
  title: 'Война и мир',
  author: 'Лев Толстой',
  pages: 1274,
  isFinished: true,
  usersReading: [1946, 1293, 7743]
}

book.usersReading = undefined
book['isFinished'] = undefined
// {
//    title: 'Война и мир',
//    author: 'Лев Толстой',
//    pages: 1274
//    isFinished: undefined,
//    usersReading: undefined
// }


ИМЕНА СВ - В

ИНОГДА ИХ НАЗЫВАЮТ КЛЮЧИ, ПОЛЯ.МОГУТ БЫТЬ СТРОКАМИ ИЛИ СИМВОЛАМИ.
ЕСЛИ ИСПОЛЬЗОВАТЬ ДРУГОЙ ТИП ДАННЫХ, ТО ОН БУДЕТ ПРИВЕДЕН К СТРОКЕ С ПОМОЩЬЮ ВЫЗОВА МЕТОДА toString()

const obj = {}
const key = {}
obj[key] = 'value for the object key'

console.log(obj)
// { '[object Object]': 'value for the object key' }

Чтение свойств 
Существует два вида синтаксиса для обращения к значению свойства объекта.В обоих случаях используется имя свойства.

Самый распространённый способ — с помощью точки:

Если прочитать свойство, которого нет у объекта, вернётся undefined:

const signature = book.signature

console.log(signature)
// undefined

Добавление и изменение свойств
Созданный объект можно изменять: добавлять, изменять и удалять свойства.

Для добавления и изменения свойств используется одинаковый синтаксис.
Нужно обратиться к свойству и присвоить в него значение с помощью стандартного оператора присваивания =.
Если свойство не существует, оно будет создано:

const book = {
  title: 'Капитанская дочка'
}

// Добавляем новое свойство
book.author = 'А. С. Пушкин'

// Изменяем существующее
book.title = 'Сказка о царе Салтане'

console.log(book)
// { title: 'Сказка о царе Салтане', author: 'А. С. Пушкин'}


Синтаксис с квадратными скобками работает и здесь:

const book = {
  title: 'Капитанская дочка'
}

// Добавляем новое свойство
book['author'] = 'А. С. Пушкин'

// Изменяем существующее
book['title'] = 'Сказка о царе Салтане'

console.log(book)
// { title: 'Сказка о царе Салтане', author: 'А. С. Пушкин'}


Сравнение объектов Скопировать ссылку "Сравнение объектов"
Объекты — ссылочный тип данных.Сравнению по ссылке посвящена отдельная статья.

При сравнении двух объектов JavaScript сравнивает не значения свойств этих объектов, а адреса в памяти, по которым эти объекты хранятся.
Поэтому любое сравнение двух объектов будет возвращать false, даже если они выглядят одинаково:

// Создаётся один объект
const book = { title: 'Дюна' }

// Создаётся другой объект
const anotherBook = { title: 'Дюна' }

console.log(book === anotherBook)
// false


Сравнение будет возвращать true, только если мы сравниваем переменные, указывающие на один и тот же объект:

// Создаётся один объект
const book = { title: 'Дюна' }

// В anotherBook записывается ссылка на объект
const anotherBook = book

console.log(book === anotherBook)
// true

КЛОНИРОВАНИЕ И ОБЪЕДИНЕНИЕ, Object.assign

Также мы можем использовать для этого метод Object.assign.

  Синтаксис:

Object.assign(dest, [src1, src2, src3...])

  - Первый аргумент dest — целевой объект.
- Остальные аргументы src1, ..., srcN(может быть столько, сколько необходимо) являются исходными объектами
  - Метод копирует свойства всех исходных объектов src1, ..., srcN в целевой объект dest.Другими словами, свойства всех аргументов, начиная со второго, копируются в первый объект.
- Возвращает объект dest.

Мы также можем использовать Object.assign для замены цикла for..in для простого клонирования:

  let user = {
    name: "John",
    age: 30
  };

let clone = Object.assign({}, user);

Как определить существует нужное свойство в объекте или нет
Чтобы определить, существует ли свойство, используйте оператор in.Он возвращает true,
  если объект имеет свойство с заданным именем, и false в противном случае.Также проверяется, есть ли свойство в прототипе объекта.

const person = {
  name: 'Igor',
  age: 30,
};

console.log('name' in person); // true
console.log('height' in person); // false
console.log('toString' in person); // true - наследуется от Object.prototype

Как перебрать свойства объекта
Цикл for…in — это способ перебрать все свойства объекта и выполнить некоторое действие для каждого из них:

for (var key in person) {
  console.log(key + ": " + person[key]);
}
// name: Alice
// age: 26
// sayHello: function () {
//      console.log("Hello, I'm " + this.name);
//   }
// height: 170


Функцию, которая является свойством объекта, называют методом этого объекта.

Для доступа к информации внутри объекта метод может использовать ключевое слово this.

Значение this – это объект «перед точкой», который используется для вызова метода.

Что такое this

Ключевое слово this одна из особенностей JS для реализации объектно - оринтированного программирования.Особенность в том что, это слово может означать разные объекты в зависимости от того где она написана.

  this - это ссылка на какой то объект.Объект, на который ссылается this может меняться в зависимости от контекста.


    Как "потерять" this ?

      Если мы решим скопировать ссылку на объект в другую переменную

      Как "не терять" this ?
  Простой вызов

в общем случае this указывает на глобальный объект.Для браузера такой объект - это само окно браузера, поэтому если набрать
console.log(this) //Window

ЕСЛИ ВКЛЮЧЕН СТРОГИЙ РЕЖИМ, ТО this БУДЕТ РАВНО undefined.


Чему равен this в свойствах объекта ?

  Если функция получена как свойство объекта и сразу же используется, то this будет равно этому объекту.


  Чему равен this в геттерах / сеттерах объекта ?



  Чему равен this внутри функции - стрелки ?

    Стрелочные функции особенные: у них нет своего «собственного» this.Если мы ссылаемся на this внутри такой функции, то оно берётся из внешней «нормальной» функции.

      Итого
Функции, которые находятся в свойствах объекта, называются «методами».
Методы позволяют объектам «действовать»: object.doSomething().
Методы могут ссылаться на объект через this.
Значение this определяется во время исполнения кода.

При объявлении любой функции в ней можно использовать this, но этот this не имеет значения до тех пор, пока функция не будет вызвана.
Функция может быть скопирована между объектами(из одного объекта в другой).
Когда функция вызывается синтаксисом «метода» – object.method(), значением this во время вызова является object.
Также ещё раз заметим, что стрелочные функции являются особенными – у них нет this.Когда внутри стрелочной функции обращаются к this, то его значение берётся извне.

const obj = {
  a: 'a',
  b: 'b',
  c: 'c',
}

const { a, b, c, ...obj4 } = obj

console.log(obj4);
KATANA - Пустая строка ''

КОНСТРУТОР, оператор new

  Функция - конструктор
Функции - конструкторы технически являются обычными функциями.Но есть два соглашения:

Имя функции - конструктора должно начинаться с большой буквы.
  Функция - конструктор должна выполняться только с помощью оператора "new".

    Например:

function User(name) {
  this.name = name;
  this.isAdmin = false;
}

let user = new User("Jack");

alert(user.name); // Jack
alert(user.isAdmin); // false
Когда функция вызывается как new User(...), происходит следующее:

-Создаётся новый пустой объект, и он присваивается this.
- Выполняется тело функции.Обычно оно модифицирует this, добавляя туда новые свойства.
- Возвращается значение this.

Обычно конструкторы не имеют оператора return.Их задача – записать все необходимое в this, и это автоматически становится результатом.

Но если return всё же есть, то применяется простое правило:

При вызове return с объектом, вместо this вернётся объект.
При вызове return с примитивным значением, оно проигнорируется.
Другими словами, return с объектом возвращает этот объект, во всех остальных случаях возвращается this.

function BigUser() {

  this.name = "John";

  return { name: "Godzilla" };  // <-- возвращает этот объект
}

alert(new BigUser().name);  // Godzilla, получили этот объект


А вот пример с пустым return

function SmallUser() {

  this.name = "John";

  return; // <-- возвращает this
}

alert(new SmallUser().name);  // John

// let user = {
//   name: 'Vitality',
//   age: 30,
//   sayHi() {
//     alert('Hello ' + this.name) //this === user
//   }
// }

// user.sayHi = function() {
//   alert('Hello')
// }

// function sayHi() {
//   alert('Hello')
// }

// user.sayHi = sayHi


// function sayHi() {
//   alert(this.name)
// }

// let user = { name: 'Vitaliy' }
// let admin = { name: 'Sergey' }

// user.f = sayHi
// admin.f = sayHi

// user.f()
// admin.f()

// function newF() {
//   const sayHi = () => {
//     alert(this.name)
//   }
//   sayHi()
// }

// let user = { name: 'Vitaliy' }
// let admin = { name: 'Sergey' }

// user.f = sayHi
// admin.f = sayHi

// user.f()
// admin.f()


// function sumary() {
//   this.name = name
// }

// console.log(name);

ТИП ДАННЫХ Symbol

представляет собой уникальный идентификатор.

создаются с помощью функции Symbol()

можно дать описание, используется для отладки кода:

let id = Symbol('id')

Символы гарантируют уникальность.Даже если создать много символов с одинаковым описанием, это все равно будут разные символы.
  Описание - это просто метка, которая ни на что не влияет.

let id1 = Symbol('id')
let id2 = Symbol('id')

alert(id1 == id2) //false

Символы не преоброазуются автоматически
это выведет ошибку

let id = Symbol('id')
alert(id)//// TypeError: Cannot convert a Symbol value to a string

это языковая защита от путаници, символы и строки - принципиально разные типы данных и не должны неконтролируемо преобразовываться друг в друга.

Если же мы действительно хотим вывести символ с помощью alert, то необходимо явно преобразовать его с помощью метода.toString(), вот так:

let id = Symbol("id");
alert(id.toString()); // Symbol(id), теперь работает

Или мы можем обратиться к свойству symbol.description, чтобы вывести только описание:

let id = Symbol("id");
alert(id.description); // id

СКРЫТЫЕ СВОЙСТВА

let user = {
  name: "Вася"
};

let id = Symbol("id");

user[id] = 1;

alert(user[id]); // мы можем получить доступ к данным по ключу-символу

Почему же лучше использовать Symbol("id"), а не строку "id" ?

  Сторонний код может создать для этого свой символ Symbol("id"):

// ...
let id = Symbol("id");

user[id] = "Их идентификатор";

Конфликта между их и нашим идентификатором не будет, так как символы всегда уникальны, даже если их имена совпадают.

А вот если бы мы использовали строку "id" вместо символа, то тогда был бы конфликт:

let user = { name: "Вася" };

// Объявляем в нашем скрипте свойство "id"
user.id = "Наш идентификатор";

// ...другой скрипт тоже хочет свой идентификатор...

user.id = "Их идентификатор"
// Ой! Свойство перезаписано сторонней библиотекой!

СИМВОЛЫ В ДИТЕРАЛЬНОМ ОБЪЕКТЕ

СИМВОЛ НЕОБХОДИМО ЗАКЛЮЧАТЬ В КВАДРАТНЫЕ СКОБКИ

let id = Symbol("id");

let user = {
  name: "Вася",
  [id]: 123 // просто "id: 123" не сработает
};

это вызвано тем, что нужно использовать значение переменной id в качестве ключа, а не строку 'id'

СИМВОЛЫ ИГНОРИРУЮТСЯ ЦИКЛОМ For..in

Свойста, чьи ключи - символы, не перебираются циклом for..in

let id = Symbol('id')
let user = {
    name: 'Vlad',
    age: 30,
    [id]: 123
  }

for (let key in user) alert(key) // name, age (свойства с ключом-символом нет среди перечисленных)

alert(// хотя прямой доступ по символу работает
  alert("Напрямую: " + user[id]);)

Это часть общего принципа 'сокрытия символьных св-в'.Если другая библиотека или скрипт будут работать с нашим объектом,
  то при переборе они не получат ненароком наше символьное свойство.

    Object.keys(user) также игнорирует символы.

  А вот Object.assign, в отличие от цикла for..in, копирует и строковые, и символьные свойства:

let id = Symbol("id");
let user = {
  [id]: 123
};

let clone = Object.assign({}, user);

alert(clone[id]); // 123

ГЛОБАЛЬНЫЕ СИМВОЛЫ

иногда мы хотим, чтобы символы с одинаковыми именами были одной сущностью.
  Например, разные части нашего приложения хотят получить доступ к символу "id", подразумевая именно одно и то же свойство.

ДЛЯ ЭТОГО СУЩЕСТВУЕТ ГЛОБАЛЬНЫЙ РЕЕСТР СИМВОЛОВ.Мы можем создавать в нем символы и обращаться  к ним позже, и 
при каждом обращении нам гарантированно будет возвращаться один и тот же символ.

для чтения символа из реестра используется вызов Symbol.for(key)

  Он проверяет глобальный реестр и, при наличии в нём символа с именем key, возвращает его, иначе же создаётся новый символ Symbol(key) и записывается в реестр под ключом key.

// читаем символ из глобального реестра и записываем его в переменную
let id = Symbol.for("id"); // если символа не существует, он будет создан

// читаем его снова и записываем в другую переменную (возможно, из другого места кода)
let idAgain = Symbol.for("id");

// проверяем -- это один и тот же символ
alert(id === idAgain); // true

Символы, содержащиеся в реестре, называются глобальными символами.
Если вам нужен символ, доступный везде в коде – используйте глобальные символы.

  Symbol.keyFor

Для глобальных символов, кроме Symbol.for(key), который ищет символ по имени,
  существует обратный метод: Symbol.keyFor(sym), который, наоборот, принимает глобальный символ и возвращает его имя.

// получаем символ по имени
let sym = Symbol.for("name");
let sym2 = Symbol.for("id");

// получаем имя по символу
alert(Symbol.keyFor(sym)); // name
alert(Symbol.keyFor(sym2)); // id

Внутри метода Symbol.keyFor используется глобальный реестр символов для нахождения имени символа.Так что этот метод не будет работать для неглобальных символов.Если символ неглобальный, метод не сможет его найти и вернёт undefined.

  Впрочем, для любых символов доступно свойство description.

    Например:

let globalSymbol = Symbol.for("name");
let localSymbol = Symbol("name");

alert(Symbol.keyFor(globalSymbol)); // name, глобальный символ
alert(Symbol.keyFor(localSymbol)); // undefined для неглобального символа

alert(localSymbol.description); // name

СИСТЕМНЫЕ СИМВОЛЫ

Существует множество «системных» символов,
  использующихся внутри самого JavaScript, и мы можем использовать их, чтобы настраивать различные аспекты поведения объектов.

Эти символы перечислены в спецификации в таблице Well - known symbols:

Symbol.hasInstance
Symbol.isConcatSpreadable
Symbol.iterator
Symbol.toPrimitive
…и так далее.

В частности, Symbol.toPrimitive позволяет описать правила для объекта, согласно которым он будет преобразовываться к примитиву. 
Мы скоро увидим его применение.

  ИТОГО

Символ(symbol) – примитивный тип данных, использующийся для создания уникальных идентификаторов.

Символы создаются вызовом функции Symbol(), в которую можно передать описание(имя) символа.

Даже если символы имеют одно и то же имя, это – разные символы. 

Если мы хотим, чтобы одноимённые символы были равны, то следует использовать глобальный реестр: 
вызов Symbol.for(key) возвращает(или создаёт) глобальный символ с key в качестве имени.
Многократные вызовы команды Symbol.for с одним и тем же аргументом возвращают один и тот же символ.

Символы имеют два основных варианта использования:

«Скрытые» свойства объектов.

Если мы хотим добавить свойство в объект, который «принадлежит» другому скрипту или библиотеке,
  мы можем создать символ и использовать его в качестве ключа.
Символьное свойство не появится в for..in, так что оно не будет нечаянно обработано вместе с другими.
Также оно не будет модифицировано прямым обращением, так как другой скрипт не знает о нашем символе.
Таким образом, свойство будет защищено от случайной перезаписи или использования.

Так что, используя символьные свойства, мы можем спрятать что - то нужное нам, но что другие видеть не должны.

Существует множество системных символов, используемых внутри JavaScript, доступных как Symbol.*.
Мы можем использовать их, чтобы изменять встроенное поведение ряда объектов.
  Например, в дальнейших главах мы будем использовать Symbol.iterator для итераторов, Symbol.toPrimitive для настройки преобразования объектов в примитивы и так далее.

Технически символы скрыты не на 100 %.Существует встроенный метод Object.getOwnPropertySymbols(obj) – с его помощью можно получить все свойства объекта с ключами - символами.
Также существует метод Reflect.ownKeys(obj), который возвращает все ключи объекта, включая символьные.
Так что они не совсем спрятаны.Но большинство библиотек, встроенных методов и синтаксических конструкций не используют эти методы.



ПРЕОБРАЗОВАНИЕ ОБЪЕКТОВ В ПРИМИТИВЫ
Что произойдёт, если сложить два объекта obj1 + obj2, вычесть один из другого obj1 - obj2 или вывести их на экран, воспользовавшись alert(obj) ?

  Это важное ограничение: результатом obj1 + obj2(или другой математической операции) не может быть другой объект!


ПРАВИЛА ПРЕОБРАЗОВАНИЯ

  - Не существует преобразования к логическому значению.В логическом контексте все объекты являются true, всё просто. 
Существует лишь их числовое и строковое преобразование.

- Числовое преобразование происходит, когда мы вычитаем объекты или применяем математические функции.
  Например, объекты Date(которые будут рассмотрены в главе Дата и время) могут быть вычтены,
    и результатом date1 - date2 будет разница во времени между двумя датами.

- Что касается преобразований к строке – оно обычно происходит,
  когда мы выводим на экран объект при помощи alert(obj) и в подобных контекстах.

    ХИНТЫ

 Существует три варианта преобразования типов

"string"
Для преобразования объекта к строке, когда мы выполняем операцию над объектом, которая ожидает строку, например alert:

// вывод
alert(obj);

// используем объект в качестве ключа
anotherObj[obj] = 123;

"number"
Для преобразования объекта к числу, в случае математических операций:

// явное преобразование
let num = Number(obj);

// математические (не считая бинарного плюса)
let n = +obj; // унарный плюс
let delta = date1 - date2;

// сравнения больше/меньше
let greater = user1 > user2;
Большинство встроенных математических функций также включают в себя такое преобразование.

"default"
Происходит редко, когда оператор «не уверен», какой тип ожидать.

  Например, бинарный плюс + может работать как со строками(объединяя их в одну), так и с числами(складывая их).
    Поэтому, если бинарный плюс получает объект в качестве аргумента, он использует хинт "default" для его преобразования.

      Также, если объект сравнивается с помощью == со строкой, числом или символом, тоже неясно,
        какое преобразование следует выполнить, поэтому используется хинт "default".

// бинарный плюс использует хинт "default"
let total = obj1 + obj2;

// obj == number использует хинт "default"
if (user == 1) { ... };
Операторы сравнения больше / меньше, такие как < >, также могут работать как со строками,
  так и с числами.Тем не менее, по историческим причинам, они используют хинт "number", а не "default".

Все встроенные объекты, за исключением одного(объект Date, который мы рассмотрим позже),
  реализуют "default" преобразование тем же способом, что и "number".И нам следует поступать так же.

ЧТОБЫ ВЫПОЛНИТЬ ПРЕОБРАЗОВАНИЕ, JS ПЫТАЕТСЯ НАЙТИ И ВЫЗВАТЬ ТРИ СЛЕДУЮЩИХ МЕТОДА

  - Вызвать obj[Symbol.toPrimitive](hint) – метод с символьным ключом Symbol.toPrimitive(системный символ), если такой метод существует,

    -Иначе, если хинт равен "string"
попробовать вызвать obj.toString() или obj.valueOf(), смотря какой из них существует.

- Иначе, если хинт равен "number" или "default"
попробовать вызвать obj.valueOf() или obj.toString(), смотря какой из них существует.

  Symbol.toPrimitive

Давайте начнём с первого метода.Есть встроенный символ с именем Symbol.toPrimitive, который следует использовать для обозначения метода преобразования, вот так:

obj[Symbol.toPrimitive] = function (hint) {
  // вот код для преобразования этого объекта в примитив
  // он должен вернуть примитивное значение
  // hint = чему-то из "string", "number", "default"
};

Если метод Symbol.toPrimitive существует, он используется для всех хинтов, и больше никаких методов не требуется.

let user = {
  name: "John",
  money: 1000,

  [Symbol.toPrimitive](hint) {
    alert(`hint: ${hint}`);
    return hint == "string" ? `{name: "${this.name}"}` : this.money;
  }
};

// демонстрация результатов преобразований:
alert(user); // hint: string -> {name: "John"}
alert(+user); // hint: number -> 1000
alert(user + 500); // hint: default -> 1500

toString / valueOf

Если нет Symbol.toPrimitive, тогда JavaScript пытается найти методы toString и valueOf:

-Для хинта "string": вызвать метод toString, а если он не существует или возвращает объект вместо примитивного значения,
  то valueOf(таким образом, toString имеет приоритет при строковом преобразовании).

- Для других хинтов: вызвать метод valueOf, а если он не существует или возвращает объект вместо примитивного значения,
  то toString(таким образом, valueOf имеет приоритет для математических операций).

Методы toString и valueOf берут своё начало с древних времён. 
Это не символы, а скорее просто «обычные» методы со строковыми именами.Они предоставляют альтернативный «старомодный» способ реализации преобразования.

Эти методы должны возвращать примитивное значение.
 Если toString или valueOf возвращает объект, то он игнорируется(так же, как если бы метода не было).

 По умолчанию обычный объект имеет следующие методы toString и valueOf:

-Метод toString возвращает строку "[object Object]".

- Метод valueOf возвращает сам объект.

let user = { name: "John" };

alert(user); // [object Object]
alert(user.valueOf() === user); // true

let user = {
  name: "John",
  money: 1000,

  // для хинта равного "string"
  toString() {
    return `{name: "${this.name}"}`;
  },

  // для хинта равного "number" или "default"
  valueOf() {
    return this.money;
  }

};

alert(user); // toString -> {name: "John"}
alert(+user); // valueOf -> 1000
alert(user + 500); // valueOf -> 1500

Довольно часто нам нужно единое «универсальное» место для обработки всех примитивных преобразований.
 В этом случае мы можем реализовать только toString:

let user = {
  name: "John",

  toString() {
    return this.name;
  }
};

alert(user); // toString -> John
alert(user + 500); // toString -> John500

ПРЕОБРАЗОВАНИЕ МОЖЕТ ВЕРНУТЬ ЛЮБОЙ ПРИМИТИВНЫЙ ТИП

Важная вещь, которую следует знать обо всех методах преобразования примитивов, заключается в том, что они не обязательно возвращают подсказанный хинтом примитив.

Нет никакого контроля над тем, вернёт ли toString именно строку, или чтобы метод Symbol.toPrimitive возвращал именно число для хинта "number".

Единственное обязательное условие: эти методы должны возвращать примитив, а не объект.


ДАЛЬНЕЙШИЕ ПРЕОБРАЗОВАНИЯ

Как мы уже знаем, многие операторы и функции выполняют преобразования типов, например, умножение * преобразует операнды в числа.

Если мы передаём объект в качестве аргумента, то в вычислениях будут две стадии:

-Объект преобразуется в примитив(с использованием правил, описанных выше).

- Если необходимо для дальнейших вычислений, этот примитив преобразуется дальше.

let obj = {
  // toString обрабатывает все преобразования в случае отсутствия других методов
  toString() {
    return "2";
  }
};

alert(obj * 2); // 4, объект был преобразован к примитиву "2", затем умножение сделало его числом

А вот, к примеру, бинарный плюс в подобной ситуации соединил бы строки, так как он совсем не брезгует строк:

let obj = {
  toString() {
    return "2";
  }
};

alert(obj + 2); // "22" ("2" + 2), преобразование к примитиву вернуло строку => конкатенация

ИТОГО

Преобразование объекта в примитив вызывается автоматически многими встроенными функциями и операторами, которые ожидают примитив в качестве значения.

Существует всего 3 типа(хинта) для этого:

"string"(для alert и других операций, которым нужна строка)
"number"(для математических операций)
"default"(для некоторых других операторов, обычно объекты реализуют его как "number")
Спецификация явно описывает для каждого оператора, какой ему следует использовать хинт.

Алгоритм преобразования таков:

1. Сначала вызывается метод obj[Symbol.toPrimitive](hint), если он существует,
  
2. В случае, если хинт равен "string"
происходит попытка вызвать obj.toString() и obj.valueOf(), смотря что есть.

3. В случае, если хинт равен "number" или "default"
происходит попытка вызвать obj.valueOf() и obj.toString(), смотря что есть.

Все эти методы должны возвращать примитив(если определены).

На практике часто бывает достаточно реализовать только obj.toString() в качестве универсального метода для преобразований к строке, 
который должен возвращать удобочитаемое представление объекта для целей логирования или отладки.

