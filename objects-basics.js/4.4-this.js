МЕТОДЫ ОБЪЕКСТА, "this"

пользователь может совершать действия: выбирать что то из корзины покупок, авторизовываться, выходить из системы, оплачивать и тд.

ПРИМЕРЫ МЕТОДОВ

let user = {
  name: "John",
  age: 30
}

user.sayHi = function () {
  alert("Привет!")
}

user.sayHi()// Привет!

ФУНКЦИЮ КОТОРАЯ ЯВЛЯЕТСЯ СВ - ВОМ ОБЪЕКТА, НАЗЫВАЮТ МЕТОДОМ ЭТОГО ОБЪЕКТА.

итак мы получили метод sayHi объекта user.


  Конечно, мы могли бы использовать заранее объявленную функцию в качестве метода, вот так:

let user = {
  // ...
};

// сначала, объявляем
function sayHi() {
  alert("Привет!");
}

// затем добавляем в качестве метода
user.sayHi = sayHi;

user.sayHi(); // Привет!


ООП - Объектно - ориентированное программирование

Когда мы пишем наш код, используя объекты для представления сущностей реального мира


СОКРАЩЕННАЯ ЗАПИСЬ МЕТОДА

user = {
  sayHi: function () {
    alert("Привет!")
  }
}

// Сокращенно 
user = {
  sayHi() {
    alert("Привет!")
  }
}

КЛЮЧЕВОЕ СЛОВО "this" В МЕТОДАХ

ДЛЯ ДОСТУПА К ИНФОРМАЦИИ ВНУТРИ ОБЪЕКТА МЕТОД МОЖЕТ ИСПОЛЬЗОВАТЬ КЛЮЧЕВОЕ СЛОВО this

Значение this - это объект перед точкой, который используется для вызова метода.

let user = {
  name: "John",
  age: 30

  sayHi() {
    //"this" - это текущий объект
    alert(this.name)
  }
}

user.sayHi() //John

Здесь во время выполнения кода user.sayHi() значением this будет являться user(ссылка на объект user).

Можно сделать и так, но такой код НЕНАДЕЖЕН!

let user = {
  name: "John",
  age: 30,

  sayHi() {
    alert(user.name); // "user" вместо "this"
  }

};

Если мы решим скопировать ссылку на объект user в другую переменную, например, admin = user, и перезапишем переменную user чем - то другим, тогда будет осуществлён доступ к неправильному объекту при вызове метода из admin.


Это показано ниже:

let user = {
  name: "John",
  age: 30,

  sayHi() {
    alert(user.name); // приведёт к ошибке
  }

};


let admin = user;
user = null; // перезапишем переменную для наглядности, теперь она не хранит ссылку на объект.

admin.sayHi(); // TypeError: Cannot read property 'name' of null
Если бы мы использовали this.name вместо user.name внутри alert, тогда этот код бы сработал.

this НЕ ЯВЛЯЕТСЯ ФИКСИРОВАННЫМ
его можно использовать в любой функции, даже если это не метод объекта.

В следующем примере нет синтаксической ошибки:

function sayHi() {
  alert(this.name);
}
Значение this вычисляется во время выполнения кода, в зависимости от контекста.

let user = { name: "John" };
let admin = { name: "Admin" };

function sayHi() {
  alert(this.name);
}

// используем одну и ту же функцию в двух объектах
user.f = sayHi;
admin.f = sayHi;

// эти вызовы имеют  разное значение this
// "this" внутри функции - это объект "перед точкой"
user.f(); // John  (this == user)
admin.f(); // Admin  (this == admin)

admin['f'](); // Admin (нет разницы между использованием точки или квадратных скобок для доступа к объекту)

ПРАВИЛО ПРОСТОЕ: если вызывается obj.f(), то во время вызова f, this – это obj.Так что, в приведённом выше примере это либо user, либо admin.

ВЫЗОВ БЕЗ ОБЪЕКТА: this == undefined

Мы даже можем вызвать функцию вообще без объекта:

function sayHi() {
  alert(this);
}

sayHi(); // undefined

В строгом режиме("use strict") в таком коде значением this будет являться undefined.Если мы попытаемся получить доступ к this.name – это вызовет ошибку.

В нестрогом режиме значением this в таком случае будет глобальный объект.Это – исторически сложившееся поведение this, которое исправляется использованием строгого режима("use strict").

Обычно подобный вызов является ошибкой программирования.Если внутри функции используется this, тогда она ожидает, что будет вызвана в контексте какого - либо объекта.


Последствия свободного this

Если вы до этого изучали другие языки программирования, то вы, вероятно, привыкли к идее «фиксированногоthis» – когда методы, определённые в объекте, всегда имеют this, ссылающееся на этот объект.

В JavaScript this является «свободным», его значение вычисляется в момент вызова метода и не зависит от того, где этот метод был объявлен, а скорее от того, какой объект вызывает метод(какой объект стоит «перед точкой»).


У СТРЕЛОЧНЫХ ФУНКЦИЙ НЕТ this
Стрелочные функции особенные: у них нет своего собственного this.если мы ссылаемся на this внутри такой функции, то оно берется ИЗ ВНЕШНЕЙ НОРМАЛЬНОЙ ФУНКЦИИ.

  Например, здесь arrow() использует значение this из внешнего метода user.sayHi():

let user = {
  firstName: "Ilya",
  sayHi() {
    let arrow = () => alert(this.firstName);
    arrow();
  }
};

user.sayHi(); // Ilya

Это особенность стрелочных функций.Она полезна, когда мы на самом деле не хотим иметь отдельное this, а скорее хотим взять его из внешнего контекста.

  ИТОГО
  - Функции, которые находятся в свойствах объекта, называются «методами».
-Методы позволяют объектам «действовать»: object.doSomething().
- Методы могут ссылаться на объект через this.

Значение this определяется во время исполнения кода.

- При объявлении любой функции в ней можно использовать this, но этот this не имеет значения до тех пор, пока функция не будет вызвана.
- Функция может быть скопирована между объектами(из одного объекта в другой).
-
  Когда функция вызывается синтаксисом «метода» – object.method(), значением this во время вызова является object.
Также ещё раз заметим, что стрелочные функции являются особенными – у них нет this.Когда внутри стрелочной функции обращаются к this, то его значение берётся извне.


  ЗАДАЧИ 

Каким будет результат при обращении к свойству объекта ref ? Почему ?

  function makeUser() {
    return {
      name: "John",
      ref: this
    };
  }

let user = makeUser();

alert(user.ref.name); // Каким будет результат?


ОТВЕТ: ошибка.

  Проверьте:

function makeUser() {
  return {
    name: "John",
    ref: this
  };
}

let user = makeUser();

alert(user.ref.name); // Error: Cannot read property 'name' of undefined

Это потому, что правила, которые определяют значение this, никак не смотрят на объявление объекта.Важен лишь момент вызова.

Здесь значение this внутри makeUser() равно undefined, потому что оно вызывается как функция, а не через «точечный» синтаксис как метод.

Значение this одно для всей функции, блоки кода и объектные литералы на него не влияют.

Таким образом, ref: this фактически принимает текущее this функции makeUser().

Мы можем переписать функцию и вернуть то же самое this со значением undefined:

function makeUser() {
  return this; // на этот раз нет литерала объекта
}

alert(makeUser().name); // Error: Cannot read property 'name' of undefined
Как вы можете видеть, результат alert(makeUser().name) совпадает с результатом alert(user.ref.name) из предыдущего примера.

Вот противоположный случай:

function makeUser() {
  return {
    name: "John",
    ref() {
      return this;
    }
  };
}

let user = makeUser();

alert(user.ref().name); // John
Теперь это работает, поскольку user.ref() – это метод.И значением this становится объект перед точкой..

СОЗДАЙТЕ КАЛЬКУЛЯТОР

let calculator = {
  sum() {
    return this.a + this.b;
  },

  mul() {
    return this.a * this.b
  },

  read() {
    this.a = +prompt('a?', 0)
    this.b = +prompt('b?', 0)
  }
};

calculator.read();
alert(calculator.sum())
alert(calculator.mul())


Цепь вызовов


У нас есть объект ladder(лестница), который позволяет подниматься и спускаться:

let ladder = {
  step: 0,
  up() {
    this.step++;
  },
  down() {
    this.step--;
  },
  showStep: function () { // показывает текущую ступеньку
    alert(this.step);
  }
};
Теперь, если нам нужно выполнить несколько последовательных вызовов, мы можем сделать это так:

ladder.up();
ladder.up();
ladder.down();
ladder.showStep(); // 1
ladder.down();
ladder.showStep(); // 0
Измените код методов up, down и showStep таким образом, чтобы их вызов можно было сделать по цепочке, например так:

ladder.up().up().down().showStep().down().showStep(); // показывает 1 затем 0


Решение состоит в том, чтобы возвращать сам объект из каждого вызова.

let ladder = {
  step: 0,
  up() {
    this.step++;
    return this;
  },
  down() {
    this.step--;
    return this;
  },
  showStep() {
    alert(this.step);
    return this;
  }
};

ladder.up().up().down().showStep().down().showStep(); // показывает 1 затем 0
Мы также можем записать один вызов на одной строке.Для длинных цепей вызовов это более читабельно:

ladder
  .up()
  .up()
  .down()
  .showStep() // 1
  .down()
  .showStep(); // 0