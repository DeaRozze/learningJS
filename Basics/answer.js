//use strict
включает в себя строгий режим выполнения JavaScript.Эта строка должна распологаться в самом начеле скрипта, иначе строгий режим не будет работать.
В строгом режиме интерпретатор будет явно выбрасывать ошибки на действия, которые ранее пропускал.Если строгий режим включен, то отключить его для файла уже нельзя.BigInt

делает следующее:

-выбрасывает ошибки, когда в коде используются некоторые небезопасные конструкции.
- выключает функции языка, которые запутывают код и потому не должны использоваться.
- предотвращает использование слов, которые могут быть использованы в качестве ключевых в будущем.

Например:
-нельзя использовать переменные без объявления(без строгого режима интепретатор создаст переменную в глобальной области видимости)
  - еще будет явная ошибка если значение поля нельзя изменить или удалить
    - параметры функции не могут иметь одинаковые имена(без use strict код выполнится без ошибок, но обратиться к переопределенному параметру будет невозможно)
      - при включенном режиме this больше не будет по умолчанию ссылаться на глобальный объект.
- запрещено использовать зарезервированные слова(let, package)

use strict называется директивой, так как это не просто строка, а специальная инструкция для интерпретатора.


//Что такое переменная?
это именованное хранилище для данных.
для создания переменной используется ключевое слово let.

// let message
// message = 'Hello'


также можно объявить с помощью слов var и const

  Константы в верхнем регистре используются в качестве псевдонимов для трудно запоминаемых значений, которые известны до начала испольнения скрипта.
  Пишутся ЗАГЛАВНЫМИ БУКВАМИ И И ИСПОЛЬЗОВАНИЕМ ПОДЧЕРКИВАНИЙ.
const COLOR_RED = '#F00'


// сколько типов данных в JS?
8 видов:
7 - примитивов
String,
  Number,
  Boolean,
  Symbol,
  BigInt,
  undefined(для неприсвоенного значения),
  null(для неизвестных значений - отдельный тип, имеющий одно значение null)
1 - ссылочный
Object

оператор typeof позвольяет увидеть какой тип данных сохранен в переменной.

- имеет две формы: typeof x or typeof (x)
  - возвращает строку с именем типа.например "string"
    - для null возвращает Object - это ошибка в языке, на самом деле это не объект.


      alert - показывает сообщение и ждет, пока пользователь нажмет кнопку < ОК > (модальное окно)

prompt - принимает два аргумента
result = prompt(title, [default ])
код отобразит окно с текстом, полем для ввода текста и кнопками ОК / ОТМЕНА
title - текст для отображения в окне
default - необязательный второй параметр, который устанавливает начальное значение в поле текста в окне.

confirm - отображает модальное окно с текстом вопроса question и двумя кнопкми ОК и ОТМЕНА
результат - true, если нажать кнопку ок.в других - false


Строкое преобразование

let value = true;
alert(typeof value) // boolean

value = String(value)
alert(typeof value) // string

Численное преобразование

alert('6' / '2') //3 строки преобразуются в числа

явное преобразование - функция Number()

let str = "123"
alert(typeof str) //string

let num = Number(str)
alert(typeof str) // number

Правила численного преобразования

undefined - NaN
null - 0
true / false - 1 / 0
string - Пробельные символы по краям обрезаются.если остается пустая строка то получаем 0, из непустой считается число.при ошибке результат NaN

логическое преобразование

Boolean();

правило преобразование
  - значение, которые интуитивно пустые, 
  вроде 0, 
  пустой строки, 
  null, 
  undefined, 
  NaN = становятся false
    - все сотальные становятся true


// что возвращают и как работают операторы?

Термины Унарный, бинарный, операнд

операнд - то, к чему применяется оператор.например, в умножении 5 * 2 два операнда

унарный - оператор который применяется к одному операнду, например знак минус который меняет знак числа на противоположный

бинарным называется оператор, который приментся к двум операндам.тот же минус существует и в бинарной форме

let x = 1, y = 3;
alert(y - x) //2 бинарный минус считается значением

ВЗЯТИЕ остатка %
  результат a % b - это остаток от целочисленного деления a на b

Сложение строк при помощи бинарного +

  если бинарный оператор + применить к строкам то он их объеденит в одну
let s = "моя" + "строка"
alert(s) //моястрока

alert(2 + 2 + '1'); // будет "41", а не "221"

Приведение к числу, унарный +

  если опернд не число, унарный плюс преобразует его в число

// Не влияет на числа
let x = 1;
alert(+x); // 1

let y = -2;
alert(+y); // -2

// Преобразует не числа в числа
alert(+true); // 1
alert(+"");   // 0

это тоже самое что Number() только короче


бинарный плюс сложит их  как строки:
let apples = '2'
let oranges = '3'
alert(apples + oranges)//23

Поэтому используем унарный плюс, чтобы преобразовать к числу:

let apples = "2";
let oranges = "3";

// оба операнда предварительно преобразованы в числа
alert(+apples + +oranges); // 5

// более длинный вариант
// alert( Number(apples) + Number(oranges) ); // 5

Писваивание = возвращает значение

let a = 1;
let b = 2;

let c = 3 - (a = b + 1);

alert(a); // 3
alert(c); // 0

присваивание по цепочке работает справа налево

сокращенная арифметика с присваиванием
let n = 2
n = n + 5
n = n * 2

Запись короче

let n = 2;
n += 5; // теперь n = 7 (работает как n = n + 5)
n *= 2; // теперь n = 14 (работает как n = n * 2)

alert(n); // 14


Инкремент / декремент

инкремент++ увеличивавет переменную на 1
декремент-- уменьшает переменную на 1

ВАЖНО ИНКРЕМЕНТ И ДЕКРЕМЕНТ МОЖНО ПРИМЕНЯТЬ ТОЛЬКО К ПЕРЕМЕННОЙ!!!!попытка использовать его на значении 5++ приведет к ошибке.BigInt

когда оператор идет после переменной - это < постфиксная форма > counter++
когда идет перед перемнной - это < префиксная форма > ++counter

Префиксная форма возвращает новое значение, постфиксная возвращает старое(до увеличения / уменьшения числа)

let counter = 1;
let a = ++counter; // (*)

alert(a); // 2

let counter = 1;
let a = counter++; // (*) меняем ++counter на counter++

alert(a); // 1

Подведём итоги:

Если результат оператора не используется, а нужно только увеличить / уменьшить переменную, тогда без разницы, какую форму использовать:

let counter = 0;
counter++;
++counter;
alert(counter); // 2, обе строки сделали одно и то же
Если хочется тут же использовать результат, то нужна префиксная форма:

let counter = 0;
alert(++counter); // 1
Если нужно увеличить и при этом получить значение переменной до увеличения – нужна постфиксная форма:

let counter = 0;
alert(counter++); // 0


ОПЕРАТОР ЗАПЯТАЯ

используется для написания более короткого кода.

вычисляя несколько выражений, разделяя их запятой.каждое выражение выполняется, но возвращается результат только последнего.

let a = (1 + 2, 3 + 4);

alert(a); // 7 (результат вычисления 3 + 4)

запятая имеет очень низкий приоретет

a = 1 + 2, 3 + 4;

alert(a); // 3
Необычный результат, правда ? Особенно учитывая то, что оператор, должен «выполнять каждое выражение, но возвращать результат только последнего».

Без скобок в a = 1 + 2, 3 + 4 сначала выполнится +, суммируя числа в a = 3, 7, затем оператор присваивания = присвоит a = 3, а то, что идёт дальше, будет проигнорировано.Всё так же, как в(a = 1 + 2), 3 + 4.


ОПЕРАТОРЫ СРАВНЕНИЯ

РЕЗУЛЬТАТ СРАВНЕНИЯ ИМЕЕТ ЛОГИЧЕСКИЙ ТИП
все операторы сравнения возвращают значения логического типа: 
true -означает да, верно, истина
false - означает нет, неверно, ложь

результат сравнения можно присвоить переменной, как и любое значение
let result = 5 > 4; // результат сравнения присваивается переменной result
alert( result ); // true

Сравнение строк

сравнивается посимвольно

alert( 'Я' > 'А' ); // true
alert( 'Коты' > 'Кода' ); // true
alert( 'Сонный' > 'Сон' ); // true

СРАВНЕНИЕ РАЗНЫХ ТИПОВ 
ПРИ СРАВНЕНИИ ЗНАЧЕНИЙ РАЗНЫХ ТИПОВ JS ПРИВОДИТ КАЖДОЕ ИЗ НИХ  К ЧИСЛУ

alert( '2' > 1 ); // true, строка '2' становится числом 2
alert( '01' == 1 ); // true, строка '01' становится числом 1


Строгое Сравнение
использование обычного стравнения == может вызывать проблемы, например оно не отличит 0 от false
alert( 0 == false ); // true
Та же проблема с пустой строкой:

alert( '' == false ); // true

Оператор строго равенства === проверяет равенство без приведения типов 
возвращает без попытки преобразовывания

СРАВНЕНИЯ null и undefined

при строгом равенстве ===
Знаечния различны, так как различны их типы
alert( null === undefined ); // false

при нестрогом равенстве ==
эти значения равны друг другу и не равны другим зачениям
alert( null == undefined ); // true

при использовании других операторов сравнения < > <= >=
Значения null/undefined преобразуются к числам: null становится 0, а undefined – NaN.

Странный результат сравнения null и 0
Сравним null с нулём:

alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) true

Несравненное значение undefined
Значение undefined несравнимо с другими значениями:

alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)

Итого
Операторы сравнения возвращают значения логического типа.
Строки сравниваются посимвольно в лексикографическом порядке.
Значения разных типов при сравнении приводятся к числу. Исключением является сравнение с помощью операторов строгого равенства/неравенства.
Значения null и undefined равны == друг другу и не равны любому другому значению.
Будьте осторожны при использовании операторов сравнений вроде > и < с переменными, которые могут принимать значения null/undefined. Хорошей идеей будет сделать отдельную проверку на null/undefined.



УСЛОВНОЕ ВЕТВЛЕНИЕ: if, '?'

нужно для выполнения действий в зависимости от условий.

Инструкция if()
  Вычисляет условаие в скобках и если результат true то выполняет блок кода

let year = prompt('В каком году была опубликована спецификация ECMAScript-2015?', '');

if (year == 2015) alert( 'Вы правы!' );


Преобразование к логическому типу 
инструкция вычисляет выражение в скобках и преобразует результат к логическому типу.!!!!

блок ELSE используется когда условие ложно

let year = prompt('В каком году была опубликована спецификация ECMAScript-2015?', '');

if (year == 2015) {
  alert( 'Да вы знаток!' );
} else {
  alert( 'А вот и неправильно!' ); // любое значение, кроме 2015
}

Условный оператор „?“

Оператор представлен знаком вопроса ?. Его также называют «тернарный», так как этот оператор, единственный в своём роде, имеет три аргумента.

let result = условие ? значение1 : значение2;

Сначала вычисляется условие: если оно истинно, тогда возвращается значение1, в противном случае – значение2.

Например:

let accessAllowed = (age > 18) ? true : false;

ЛОГИЧЕСКИЕ ОПЕРАТОРЫ
В JavaScript есть семь логических операторов:

|| (ИЛИ)
||= (Оператор логического присваивания ИЛИ)
&& (И)
&&= (Оператор логического присваивания И)
! (НЕ)
?? (Оператор нулевого слияния)
??= (Оператор нулевого присваивания)

|| или

result = a || b;

традиционно предназначен для булевых значений. если true - вернет true, в противоположной ситуации возращается false

alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false

ЕСЛИ ЗНАЧЕНИЕ НЕ ЛОГИЧЕСКОГО ТИПО ТО ОНО К НЕМУ ПРИВОДИТСЯ В ЦЕЛЯХ ВЫЧИСЛЕНИЙ

if (1 || 0) { // работает как if( true || false )
  alert( 'истинно!' );
}

ИЛИ || НАХОДИТ ПЕРВОЕ ИСТИННОЕ ЗНАЧЕНИЕ

Оператор || выполняет следующие действия:

Вычисляет операнды слева направо.
Каждый операнд конвертирует в логическое значение. Если результат true, останавливается и возвращает исходное значение этого операнда.
Если все операнды являются ложными (false), возвращает последний из них.

1.Получение первого истинного значения из списка переменных или выражений
2. сокращенное вычисление


||= (Логическое присваивание ИЛИ)

a ||= b;

Оператор ||= принимает два операнда и выполняет следующие действия:

Вычисляет операнды слева направо.
Конвертирует a в логическое значение.
Если a ложно, присваивает a значение b.

все равно что a || (a = b);

&& (И)

В традиционном программировании И возвращает true, если оба аргумента истинны, а иначе – false:

alert( true && true );   // true
alert( false && true );  // false
alert( true && false );  // false
alert( false && false ); // false

И «&&» находит первое ложное значение
При нескольких подряд операторах И:

result = value1 && value2 && value3;
Оператор && выполняет следующие действия:

Вычисляет операнды слева направо.
Каждый операнд преобразует в логическое значение. Если результат false, останавливается и возвращает исходное значение этого операнда.
Если все операнды были истинными, возвращается последний.

Приоритет оператора && больше, чем у ||
Приоритет оператора И && больше, чем ИЛИ ||, так что он выполняется раньше.

&&= (Логическое присваивание И)

a &&= b;
Принцип действия &&= практически такой же, как и у оператора логического присваивания ИЛИ ||=. Единственное отличие заключается в том, что &&= присвоит a значение b только в том случае, если a истинно.

let greeting = "Привет"; // строка непустая, поэтому будет преобразована к логическому значению true оператором &&=

greeting &&= greeting + ", пользователь!"; // то же самое, что true && (greeting = greeting + "...")

alert( greeting ) // "Привет, пользователь!"

! (НЕ)

Оператор принимает один аргумент и выполняет следующие действия:

Сначала приводит аргумент к логическому типу true/false.
Затем возвращает противоположное значение.

Приоритет НЕ ! является наивысшим из всех логических операторов, поэтому он всегда выполняется первым, перед && или ||.

Операторы нулевого слияния и присваивания: '??', '??='

Результат выражения a ?? b будет следующим:

если a определено, то a,
если a не определено, то b.

Иначе говоря, оператор ?? возвращает первый аргумент, если он не null/undefined, иначе второй.
result = (a !== null && a !== undefined) ? a : b;

Приоритет оператора ?? такой же, как и у ||

Оператор нулевого слияния ?? — это быстрый способ выбрать первое «определённое» значение из списка.

Используется для присвоения переменным значений по умолчанию:

// будет height=100, если переменная height равна null или undefined
height = height ?? 100;
Оператор ?? имеет очень низкий приоритет, лишь немного выше, чем у ? и =, поэтому при использовании его в выражении, скорее всего, потребуются скобки.

Запрещено использовать вместе с || или && без явно указанного приоритета, то есть без скобок.

Для присвоения переменной значения в зависимости от того, «определена» она или нет, используется оператор нулевого присваивания ??=.

Циклы while и for

создать однотипное действие много раз
для многократного повторения одного участка кода предусмотрены циклы.

Цикл «while»
Цикл while имеет следующий синтаксис:

while (condition) {
  // код
  // также называемый "телом цикла"
}
Код из тела цикла выполняется, пока условие condition истинно.

Например, цикл ниже выводит i, пока i < 3:

let i = 0;
while (i < 3) { // выводит 0, затем 1, затем 2
  alert( i );
  i++;
}
одно выполнение - итерация

Фигурные скобки не требуются для тела цикла из одной строки
Если тело цикла состоит лишь из одной инструкции, мы можем опустить фигурные скобки {…}:

let i = 3;
while (i) alert(i--);

Цикл «do…while»

Проверку условия можно разместить под телом цикла, используя специальный синтаксис do..while:

do {
  // тело цикла
} while (condition);

let i = 0;
do {
  alert( i );
  i++;
} while (i < 3);
Такая форма синтаксиса оправдана, если вы хотите, чтобы тело цикла выполнилось хотя бы один раз, даже если условие окажется ложным. На практике чаще используется форма с предусловием: while(…) {…}.

Цикл «for»

for (начало; условие; шаг) {
  // ... тело цикла ...
}

for (let i = 0; i < 3; i++) { // выведет 0, затем 1, затем 2
  alert(i);
}

часть		
начало	let i = 0	Выполняется один раз при входе в цикл
условие	i < 3	Проверяется перед каждой итерацией цикла.
Если оно вычислится в false, цикл остановится.
тело	alert(i)	Выполняется снова и снова, пока условие вычисляется в true.
шаг	i++	Выполняется после тела цикла на каждой итерации перед проверкой условия.


while – Проверяет условие перед каждой итерацией.
do..while – Проверяет условие после каждой итерации.
for (;;) – Проверяет условие перед каждой итерацией, есть возможность задать дополнительные настройки.

Чтобы организовать бесконечный цикл, используют конструкцию while (true). При этом он, как и любой другой цикл, может быть прерван директивой break.
Если на данной итерации цикла делать больше ничего не надо, но полностью прекращать цикл не следует – используют директиву continue.
Обе этих директивы поддерживают метки, которые ставятся перед циклом. Метки – единственный способ для break/continue выйти за пределы текущего цикла, повлиять на выполнение внешнего.


Конструкция "switch"
Конструкция switch заменяет собой сразу несколько if.
Она представляет собой более наглядный способ сравнить выражение сразу с несколькими вариантами.

Синтаксис
Конструкция switch имеет один или более блок case и необязательный блок default.

Выглядит она так:

switch(x) {
  case 'value1':  // if (x === 'value1')
    ...
    [break]

  case 'value2':  // if (x === 'value2')
    ...
    [break]

  default:
    ...
    [break]
}
Переменная x проверяется на строгое равенство первому значению value1, затем второму value2 и так далее.
Если соответствие установлено – switch начинает выполняться от соответствующей директивы case и далее, до ближайшего break (или до конца switch).
Если ни один case не совпал – выполняется (если есть) вариант default.

Если break нет, то выполнение пойдёт ниже по следующим case, при этом остальные проверки игнорируются.

Любое выражение может быть аргументом для switch/case

Тип имеет значение
Нужно отметить, что проверка на равенство всегда строгая. Значения должны быть одного типа, чтобы выполнялось равенство.

ФУНКЦИИ

чтобы не повторять один и тот же код во многих местах придуманы функции.
ФУНКЦИИ -ОСНОВНОЙ СТРОИТЕЛЬНЫЙ БЛОК ПРОГРАММЫ

Примеры встроенных функций вы уже видели – это alert(message), prompt(message, default) и confirm(question). Но можно создавать и свои.

Локальные переменные

ПЕРЕМЕННЫЕ ОБЪЯВЛЕННЫЕ ВНУТРИ ФУНКЦИИ ВИДНЫ ТОЛЬКО ВНУТРИ ЭТОЙ ФУНКЦИИ

у функции есть доступ к внешним переменным, но она используется только если внутри функции нет такой локальной


ПАРАМЕТРЫ
мы можем передать внутрь функции любую информацию, используя параметры

function showMessage(from, text) { // параметры: from, text
  alert(from + ': ' + text);
}

showMessage('Аня', 'Привет!'); // Аня: Привет! (*)
showMessage('Аня', "Как дела?"); // Аня: Как дела? (**)

Другими словами:

Параметр – это переменная, указанная в круглых скобках в объявлении функции.
Аргумент – это значение, которое передаётся функции при её вызове.

Значения по умолчанию

function showMessage(from, text = "текст не добавлен") {
  alert( from + ": " + text );
}

showMessage("Аня"); // Аня: текст не добавлен

Возврат значения

Функция может вернуть результат, который будет передан в вызвавший её код.

function sum(a, b) {
  return a + b;
}

let result = sum(1, 2);
alert( result ); // 3

Директива return может находиться в любом месте тела функции. Как только выполнение доходит до этого места, функция останавливается, и значение возвращается в вызвавший её код 

Возможно использовать return и без значения. Это приведёт к немедленному выходу из функции.

Результат функции с пустым return или без него – 

Итого
Объявление функции имеет вид:

function имя(параметры, через, запятую) {
  /* тело, код функции */
}
Передаваемые значения копируются в параметры функции и становятся локальными переменными.
Функции имеют доступ к внешним переменным. Но это работает только изнутри наружу. Код вне функции не имеет доступа к её локальным переменным.
Функция может возвращать значение. Если этого не происходит, тогда результат равен undefined.

Для того, чтобы сделать код более чистым и понятным, рекомендуется использовать локальные переменные и параметры функций, не пользоваться внешними переменными.

Функция, которая получает параметры, работает с ними и затем возвращает результат, гораздо понятнее функции, вызываемой без параметров, но изменяющей внешние переменные, что чревато побочными эффектами.

Именование функций:

Имя функции должно понятно и чётко отражать, что она делает. Увидев её вызов в коде, вы должны тут же понимать, что она делает, и что возвращает.
Функция – это действие, поэтому её имя обычно является глаголом.
Есть много общепринятых префиксов, таких как: create…, show…, get…, check… и т.д. Пользуйтесь ими как подсказками, поясняющими, что делает функция.
Функции являются основными строительными блоками скриптов. Мы рассмотрели лишь основы функций в JavaScript, но уже сейчас можем создавать и использовать их. Это только начало пути. Мы будем неоднократно возвращаться к функциям и изучать их всё более и более глубоко.


Function Expression

Синтаксис, который мы использовали до этого, называется Function Declaration (Объявление Функции):

function sayHi() {
  alert( "Привет" );
}

Существует ещё один синтаксис создания функций, который называется Function Expression (Функциональное Выражение).

Данный синтаксис позволяет нам создавать новую функцию в середине любого выражения.

Это выглядит следующим образом:

let sayHi = function() {
  alert( "Привет" );
};

Функция – это значение

Давайте повторим: независимо от того, как создаётся функция – она является значением. 
Но всё же это значение. Поэтому мы можем работать с ней так же, как и с другими видами значений.

Функция – это значение, представляющее «действие»

Function Declaration: функция объявляется отдельной конструкцией «function…» в основном потоке кода.

Function Declaration может быть вызвана раньше, чем она объявлена.

В строгом режиме, когда Function Declaration находится в блоке {...}, функция доступна везде внутри блока. Но не снаружи него.

Function Expression: функция, созданная внутри другого выражения или синтаксической конструкции. В данном случае функция создаётся в правой части «выражения присваивания» =:

Function Expression создаётся, когда выполнение доходит до него, и затем уже может использоваться.

Итого
Функции – это значения. Они могут быть присвоены, скопированы или объявлены в любом месте кода.
Если функция объявлена как отдельная инструкция в основном потоке кода, то это “Function Declaration”.
Если функция была создана как часть выражения, то это “Function Expression”.
Function Declaration обрабатываются перед выполнением блока кода. Они видны во всём блоке.
Функции, объявленные при помощи Function Expression, создаются только когда поток выполнения достигает их.

Стрелочные функции, основы

let func = (arg1, arg2, ...argN) => expression;

Итого
Стрелочные функции очень удобны для простых действий, особенно для однострочных.

let sum = (a, b) => a + b;

/* Эта стрелочная функция представляет собой более короткую форму:

let sum = function(a, b) {
  return a + b;
};
*/

alert( sum(1, 2) ); // 3
Они бывают двух типов:

Без фигурных скобок: (...args) => expression – правая сторона выражения: функция вычисляет его и возвращает результат. Скобки можно не ставить, если аргумент только один: n => n * 2.
С фигурными скобками: (...args) => { body } – скобки позволяют нам писать несколько инструкций внутри функции, но при этом необходимо явно вызывать return, чтобы вернуть значение.


Функции колбэки

function ask(question,yes, no) {
  if (confirm(question)) yes()
    else no()
}

function showOk() {
  alert("Вы согласны")
}

function showCancel() {
  alert("Вы отменили выполнение")
}

//использование: функции showOk, showCancel передаются в качестве аргументов ask
ask("Вы согласны?", showOk, showCancel)

Аргументы showOk и showCancel функции ask называются функциями-колбэками или просто колбэками.

Мы можем переписать этот пример значительно короче, используя Function Expression:

function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "Вы согласны?",
  function() { alert("Вы согласились."); },
  function() { alert("Вы отменили выполнение."); }
);